// tslint:disable:max-line-length
// tslint:disable:no-redundant-jsdoc

/**
 * Banco Galicia - Hackaton 2019
 * Definición de la API para el Hackaton de Banco Galicia
 *
 * OpenAPI spec version: 1.0.0
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
    HttpClient, HttpHeaders, HttpParams,
    HttpResponse, HttpEvent
} from '@angular/common/http';
import { CustomHttpUrlEncodingCodec } from '../encoder';

import { AccountCreationData } from '../model/accountCreationData';
import { AccountData } from '../model/accountData';
import { AssetData } from '../model/assetData';
import { AssetValuesData } from '../model/assetValuesData';
import { AtmData } from '../model/atmData';
import { BranchData } from '../model/branchData';
import { CancelDebtData } from '../model/cancelDebtData';
import { ChargeCreationData } from '../model/chargeCreationData';
import { ChargesData } from '../model/chargesData';
import { CreditCardCreationData } from '../model/creditCardCreationData';
import { CreditCardData } from '../model/creditCardData';
import { CustomerCreationData } from '../model/customerCreationData';
import { CustomerData } from '../model/customerData';
import { DebinCreationData } from '../model/debinCreationData';
import { DebinData } from '../model/debinData';
import { DebinPayData } from '../model/debinPayData';
import { DebtorsData } from '../model/debtorsData';
import { FundData } from '../model/fundData';
import { InversmentCreationData } from '../model/inversmentCreationData';
import { InversmentData } from '../model/inversmentData';
import { LoanCreationData } from '../model/loanCreationData';
import { LoanData } from '../model/loanData';
import { LoanSimulationData } from '../model/loanSimulationData';
import { MerchantCreationData } from '../model/merchantCreationData';
import { MerchantData } from '../model/merchantData';
import { MessageInfo } from '../model/messageInfo';
import { PaymentData } from '../model/paymentData';
import { PurchaseCreationData } from '../model/purchaseCreationData';
import { PurchaseData } from '../model/purchaseData';
import { SubscriptionCreationData } from '../model/subscriptionCreationData';
import { SubscriptionData } from '../model/subscriptionData';
import { SubscriptionUpdateData } from '../model/subscriptionUpdateData';
import { TransferCreationData } from '../model/transferCreationData';
import { TransferData } from '../model/transferData';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { Observable } from 'rxjs';


@Injectable()
export class DefaultService {

    protected basePath = 'https://api-2445582796097.staging.gw.apicast.io/api/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient,
        @Optional() @Inject(BASE_PATH) basePath: string,
        @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Crea una nueva inversion
     *
     * @param apikey
     * @param accountId
     * @param assetId
     * @param inversmentCreationData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsAccountIdInversmentsAssetIdPost(apikey: string, accountId: string, assetId: string, inversmentCreationData?: InversmentCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<InversmentData>>;
    public accountsAccountIdInversmentsAssetIdPost(apikey: string, accountId: string, assetId: string, inversmentCreationData?: InversmentCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InversmentData>>>;
    public accountsAccountIdInversmentsAssetIdPost(apikey: string, accountId: string, assetId: string, inversmentCreationData?: InversmentCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InversmentData>>>;
    public accountsAccountIdInversmentsAssetIdPost(apikey: string, accountId: string, assetId: string, inversmentCreationData?: InversmentCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsAccountIdInversmentsAssetIdPost.');
        }

        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountsAccountIdInversmentsAssetIdPost.');
        }

        if (assetId === null || assetId === undefined) {
            throw new Error('Required parameter assetId was null or undefined when calling accountsAccountIdInversmentsAssetIdPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<InversmentData>>(`${this.basePath}/accounts/${encodeURIComponent(String(accountId))}/inversments/${encodeURIComponent(String(assetId))}`,
            inversmentCreationData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Devuelve todos los registros que posee la entidad Account
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AccountData>>;
    public accountsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AccountData>>>;
    public accountsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AccountData>>>;
    public accountsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<AccountData>>(`${this.basePath}/accounts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Devuelve el registro de la entidad Account filtrado por el campo id
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<AccountData>;
    public accountsIdGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AccountData>>;
    public accountsIdGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AccountData>>;
    public accountsIdGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AccountData>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el listado de las inversiones con sus datos para la cuenta seleccionada.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdInversmentsGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InversmentData>>;
    public accountsIdInversmentsGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InversmentData>>>;
    public accountsIdInversmentsGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InversmentData>>>;
    public accountsIdInversmentsGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdInversmentsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdInversmentsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InversmentData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/inversments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna todas los préstamos asociados con un id de Cuenta especificado.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdLoansGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<LoanData>>;
    public accountsIdLoansGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<LoanData>>>;
    public accountsIdLoansGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<LoanData>>>;
    public accountsIdLoansGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdLoansGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdLoansGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<LoanData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/loans`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea una nueva Solicitud de Préstamo asociada a un id de la cuenta.
     *
     * @param apikey
     * @param id
     * @param loanData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdLoansPost(apikey: string, id: string, loanData: LoanCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<LoanData>>;
    public accountsIdLoansPost(apikey: string, id: string, loanData: LoanCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<LoanData>>>;
    public accountsIdLoansPost(apikey: string, id: string, loanData: LoanCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<LoanData>>>;
    public accountsIdLoansPost(apikey: string, id: string, loanData: LoanCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdLoansPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdLoansPost.');
        }

        if (loanData === null || loanData === undefined) {
            throw new Error('Required parameter loanData was null or undefined when calling accountsIdLoansPost.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<LoanData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/loans`,
            loanData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene todos los pagos realizados por una cuenta
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdPaymentsGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PaymentData>>;
    public accountsIdPaymentsGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PaymentData>>>;
    public accountsIdPaymentsGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PaymentData>>>;
    public accountsIdPaymentsGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdPaymentsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdPaymentsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PaymentData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/payments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna el listado de todos las subscripciones existentes asociadas a la cuenta definida por parametro
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdSubscriptionsGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SubscriptionData>>;
    public accountsIdSubscriptionsGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SubscriptionData>>>;
    public accountsIdSubscriptionsGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SubscriptionData>>>;
    public accountsIdSubscriptionsGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdSubscriptionsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdSubscriptionsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SubscriptionData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/subscriptions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea una nueva subscripción
     *
     * @param apikey
     * @param id
     * @param transferData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdSubscriptionsPost(apikey: string, id: string, transferData?: SubscriptionCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<SubscriptionData>>;
    public accountsIdSubscriptionsPost(apikey: string, id: string, transferData?: SubscriptionCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SubscriptionData>>>;
    public accountsIdSubscriptionsPost(apikey: string, id: string, transferData?: SubscriptionCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SubscriptionData>>>;
    public accountsIdSubscriptionsPost(apikey: string, id: string, transferData?: SubscriptionCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdSubscriptionsPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdSubscriptionsPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<SubscriptionData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/subscriptions`,
            transferData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Agrega o rescata fondos de una subscripción
     *
     * @param apikey
     * @param id
     * @param transferData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdSubscriptionsPut(apikey: string, id: string, transferData?: SubscriptionUpdateData, observe?: 'body', reportProgress?: boolean): Observable<Array<SubscriptionData>>;
    public accountsIdSubscriptionsPut(apikey: string, id: string, transferData?: SubscriptionUpdateData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SubscriptionData>>>;
    public accountsIdSubscriptionsPut(apikey: string, id: string, transferData?: SubscriptionUpdateData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SubscriptionData>>>;
    public accountsIdSubscriptionsPut(apikey: string, id: string, transferData?: SubscriptionUpdateData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdSubscriptionsPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdSubscriptionsPut.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Array<SubscriptionData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/subscriptions`,
            transferData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna todas las Transferencias asociadas con un id de Cuenta especificado.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdTransfersGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<TransferData>>;
    public accountsIdTransfersGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TransferData>>>;
    public accountsIdTransfersGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TransferData>>>;
    public accountsIdTransfersGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdTransfersGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdTransfersGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TransferData>>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/transfers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea una nueva Transferencia.
     *
     * @param apikey
     * @param id
     * @param transferData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountsIdTransfersPost(apikey: string, id: string, transferData?: TransferCreationData, observe?: 'body', reportProgress?: boolean): Observable<TransferData>;
    public accountsIdTransfersPost(apikey: string, id: string, transferData?: TransferCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransferData>>;
    public accountsIdTransfersPost(apikey: string, id: string, transferData?: TransferCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransferData>>;
    public accountsIdTransfersPost(apikey: string, id: string, transferData?: TransferCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling accountsIdTransfersPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling accountsIdTransfersPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TransferData>(`${this.basePath}/accounts/${encodeURIComponent(String(id))}/transfers`,
            transferData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos de los activos en los cuales se puede invertir
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assetsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AssetData>>;
    public assetsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AssetData>>>;
    public assetsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AssetData>>>;
    public assetsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling assetsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<AssetData>>(`${this.basePath}/assets`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos del activo por id
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assetsIdGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<AssetData>;
    public assetsIdGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AssetData>>;
    public assetsIdGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AssetData>>;
    public assetsIdGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling assetsIdGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling assetsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AssetData>(`${this.basePath}/assets/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene las cotizaciones del activo por id para la fecha
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public assetsIdValuesGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<AssetValuesData>;
    public assetsIdValuesGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AssetValuesData>>;
    public assetsIdValuesGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AssetValuesData>>;
    public assetsIdValuesGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling assetsIdValuesGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling assetsIdValuesGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AssetValuesData>(`${this.basePath}/assets/${encodeURIComponent(String(id))}/values`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el listado de atms / cajeros automáticos con sus datos.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public atmsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AtmData>>;
    public atmsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AtmData>>>;
    public atmsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AtmData>>>;
    public atmsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling atmsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<AtmData>>(`${this.basePath}/atms`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos del atm / cajero automático por id
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public atmsIdGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<AtmData>;
    public atmsIdGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<AtmData>>;
    public atmsIdGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<AtmData>>;
    public atmsIdGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling atmsIdGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling atmsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<AtmData>(`${this.basePath}/atms/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el listado de las sucursales con sus datos.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public branchesGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<BranchData>>;
    public branchesGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<BranchData>>>;
    public branchesGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<BranchData>>>;
    public branchesGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling branchesGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<BranchData>>(`${this.basePath}/branches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos de la sucursal por id
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public branchesIdGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<BranchData>;
    public branchesIdGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<BranchData>>;
    public branchesIdGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<BranchData>>;
    public branchesIdGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling branchesIdGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling branchesIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<BranchData>(`${this.basePath}/branches/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancela un cargo pendiente
     *
     * @param apikey
     * @param chargeId
     * @param debtorId
     * @param cancelDebtData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public chargesChargeIdDebtorsDebtorIdCancelDebtPost(apikey: string, chargeId: string, debtorId: string, cancelDebtData: CancelDebtData, observe?: 'body', reportProgress?: boolean): Observable<DebtorsData>;
    public chargesChargeIdDebtorsDebtorIdCancelDebtPost(apikey: string, chargeId: string, debtorId: string, cancelDebtData: CancelDebtData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DebtorsData>>;
    public chargesChargeIdDebtorsDebtorIdCancelDebtPost(apikey: string, chargeId: string, debtorId: string, cancelDebtData: CancelDebtData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DebtorsData>>;
    public chargesChargeIdDebtorsDebtorIdCancelDebtPost(apikey: string, chargeId: string, debtorId: string, cancelDebtData: CancelDebtData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling chargesChargeIdDebtorsDebtorIdCancelDebtPost.');
        }

        if (chargeId === null || chargeId === undefined) {
            throw new Error('Required parameter chargeId was null or undefined when calling chargesChargeIdDebtorsDebtorIdCancelDebtPost.');
        }

        if (debtorId === null || debtorId === undefined) {
            throw new Error('Required parameter debtorId was null or undefined when calling chargesChargeIdDebtorsDebtorIdCancelDebtPost.');
        }

        if (cancelDebtData === null || cancelDebtData === undefined) {
            throw new Error('Required parameter cancelDebtData was null or undefined when calling chargesChargeIdDebtorsDebtorIdCancelDebtPost.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DebtorsData>(`${this.basePath}/charges/${encodeURIComponent(String(chargeId))}/debtors/${encodeURIComponent(String(debtorId))}/cancelDebt`,
            cancelDebtData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene todos los cargos generados.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public chargesGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<ChargesData>>;
    public chargesGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ChargesData>>>;
    public chargesGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ChargesData>>>;
    public chargesGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling chargesGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<ChargesData>>(`${this.basePath}/charges`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los deudores del cargo seleccionado
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public chargesIdDebtorsGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DebtorsData>>;
    public chargesIdDebtorsGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DebtorsData>>>;
    public chargesIdDebtorsGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DebtorsData>>>;
    public chargesIdDebtorsGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling chargesIdDebtorsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling chargesIdDebtorsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<DebtorsData>>(`${this.basePath}/charges/${encodeURIComponent(String(id))}/debtors`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos del cargo seleccionado
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public chargesIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<ChargesData>;
    public chargesIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ChargesData>>;
    public chargesIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ChargesData>>;
    public chargesIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling chargesIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling chargesIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ChargesData>(`${this.basePath}/charges/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un nuevo cargo
     *
     * @param apikey
     * @param chargeCreationData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public chargesPost(apikey: string, chargeCreationData: ChargeCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<DebtorsData>>;
    public chargesPost(apikey: string, chargeCreationData: ChargeCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DebtorsData>>>;
    public chargesPost(apikey: string, chargeCreationData: ChargeCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DebtorsData>>>;
    public chargesPost(apikey: string, chargeCreationData: ChargeCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling chargesPost.');
        }

        if (chargeCreationData === null || chargeCreationData === undefined) {
            throw new Error('Required parameter chargeCreationData was null or undefined when calling chargesPost.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<DebtorsData>>(`${this.basePath}/charges`,
            chargeCreationData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el listado de las tarjetas de credito con sus datos.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public creditcardsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CreditCardData>>;
    public creditcardsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CreditCardData>>>;
    public creditcardsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CreditCardData>>>;
    public creditcardsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling creditcardsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CreditCardData>>(`${this.basePath}/creditcards`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene la tarjetas de credito con sus datos por id
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public creditcardsIdGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<CreditCardData>;
    public creditcardsIdGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreditCardData>>;
    public creditcardsIdGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreditCardData>>;
    public creditcardsIdGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling creditcardsIdGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling creditcardsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CreditCardData>(`${this.basePath}/creditcards/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene todos los pagos realizados por una tarjeta de credito
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public creditcardsIdPaymentsGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PaymentData>>;
    public creditcardsIdPaymentsGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PaymentData>>>;
    public creditcardsIdPaymentsGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PaymentData>>>;
    public creditcardsIdPaymentsGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling creditcardsIdPaymentsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling creditcardsIdPaymentsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PaymentData>>(`${this.basePath}/creditcards/${encodeURIComponent(String(id))}/payments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea una tarjeta de credito
     *
     * @param apikey
     * @param merchantData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public creditcardsPost(apikey: string, merchantData: CreditCardCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<CreditCardData>>;
    public creditcardsPost(apikey: string, merchantData: CreditCardCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CreditCardData>>>;
    public creditcardsPost(apikey: string, merchantData: CreditCardCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CreditCardData>>>;
    public creditcardsPost(apikey: string, merchantData: CreditCardCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling creditcardsPost.');
        }

        if (merchantData === null || merchantData === undefined) {
            throw new Error('Required parameter merchantData was null or undefined when calling creditcardsPost.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<CreditCardData>>(`${this.basePath}/creditcards`,
            merchantData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el listado de los clientes con sus datos.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CustomerData>>;
    public customersGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CustomerData>>>;
    public customersGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CustomerData>>>;
    public customersGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CustomerData>>(`${this.basePath}/customers`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Devuelve los registro de la entidad Account filtrando por el campo Customer_ID
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersIdAccountsGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<AccountData>>;
    public customersIdAccountsGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AccountData>>>;
    public customersIdAccountsGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AccountData>>>;
    public customersIdAccountsGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customersIdAccountsGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersIdAccountsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<AccountData>>(`${this.basePath}/customers/${encodeURIComponent(String(id))}/accounts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un registro de la entidad Account asociado al Customer_ID provisto
     *
     * @param id
     * @param apikey
     * @param accountData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersIdAccountsPost(id: string, apikey: string, accountData?: AccountCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<AccountData>>;
    public customersIdAccountsPost(id: string, apikey: string, accountData?: AccountCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<AccountData>>>;
    public customersIdAccountsPost(id: string, apikey: string, accountData?: AccountCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<AccountData>>>;
    public customersIdAccountsPost(id: string, apikey: string, accountData?: AccountCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customersIdAccountsPost.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersIdAccountsPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<AccountData>>(`${this.basePath}/customers/${encodeURIComponent(String(id))}/accounts`,
            accountData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Para un cliente en particular, obtiene el listado de las tarjetas de credito con sus datos.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersIdCreditcardsGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CreditCardData>>;
    public customersIdCreditcardsGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CreditCardData>>>;
    public customersIdCreditcardsGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CreditCardData>>>;
    public customersIdCreditcardsGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersIdCreditcardsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customersIdCreditcardsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<CreditCardData>>(`${this.basePath}/customers/${encodeURIComponent(String(id))}/creditcards`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los debines con sus datos para el cliente solicitado.
     *
     * @param apikey
     * @param id
     * @param debinData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersIdDebinsGet(apikey: string, id: string, debinData: DebinCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<DebinData>>;
    public customersIdDebinsGet(apikey: string, id: string, debinData: DebinCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DebinData>>>;
    public customersIdDebinsGet(apikey: string, id: string, debinData: DebinCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DebinData>>>;
    public customersIdDebinsGet(apikey: string, id: string, debinData: DebinCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersIdDebinsGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customersIdDebinsGet.');
        }

        if (debinData === null || debinData === undefined) {
            throw new Error('Required parameter debinData was null or undefined when calling customersIdDebinsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.get<Array<DebinData>>(`${this.basePath}/customers/${encodeURIComponent(String(id))}/debins`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Genera un nuevo debin
     *
     * @param apikey
     * @param id
     * @param debinCreationData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersIdDebinsPost(apikey: string, id: string, debinCreationData?: DebinCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<DebinData>>;
    public customersIdDebinsPost(apikey: string, id: string, debinCreationData?: DebinCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DebinData>>>;
    public customersIdDebinsPost(apikey: string, id: string, debinCreationData?: DebinCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DebinData>>>;
    public customersIdDebinsPost(apikey: string, id: string, debinCreationData?: DebinCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersIdDebinsPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customersIdDebinsPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<DebinData>>(`${this.basePath}/customers/${encodeURIComponent(String(id))}/debins`,
            debinCreationData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos del cliente por id
     *
     * @param id
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersIdGet(id: string, apikey: string, observe?: 'body', reportProgress?: boolean): Observable<CustomerData>;
    public customersIdGet(id: string, apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerData>>;
    public customersIdGet(id: string, apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerData>>;
    public customersIdGet(id: string, apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customersIdGet.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CustomerData>(`${this.basePath}/customers/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Actualiza los datos del cliente obtenido por id
     *
     * @param id
     * @param apikey
     * @param customerData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersIdPut(id: string, apikey: string, customerData?: CustomerCreationData, observe?: 'body', reportProgress?: boolean): Observable<CustomerData>;
    public customersIdPut(id: string, apikey: string, customerData?: CustomerCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerData>>;
    public customersIdPut(id: string, apikey: string, customerData?: CustomerCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerData>>;
    public customersIdPut(id: string, apikey: string, customerData?: CustomerCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customersIdPut.');
        }

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersIdPut.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<CustomerData>(`${this.basePath}/customers/${encodeURIComponent(String(id))}`,
            customerData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un nuevo cliente
     *
     * @param apikey
     * @param customerData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public customersPost(apikey: string, customerData?: CustomerCreationData, observe?: 'body', reportProgress?: boolean): Observable<CustomerData>;
    public customersPost(apikey: string, customerData?: CustomerCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CustomerData>>;
    public customersPost(apikey: string, customerData?: CustomerCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CustomerData>>;
    public customersPost(apikey: string, customerData?: CustomerCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling customersPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<CustomerData>(`${this.basePath}/customers`,
            customerData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un dataset desde la base asociado con la clave de API
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public dataPost(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<MessageInfo>;
    public dataPost(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MessageInfo>>;
    public dataPost(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MessageInfo>>;
    public dataPost(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling dataPost.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<MessageInfo>(`${this.basePath}/data`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Paga un debin
     *
     * @param apikey
     * @param debinId
     * @param accountId
     * @param debinPaymentData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public debinsDebinIdPayAccountIdPost(apikey: string, debinId: string, accountId: string, debinPaymentData?: DebinPayData, observe?: 'body', reportProgress?: boolean): Observable<Array<DebinData>>;
    public debinsDebinIdPayAccountIdPost(apikey: string, debinId: string, accountId: string, debinPaymentData?: DebinPayData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DebinData>>>;
    public debinsDebinIdPayAccountIdPost(apikey: string, debinId: string, accountId: string, debinPaymentData?: DebinPayData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DebinData>>>;
    public debinsDebinIdPayAccountIdPost(apikey: string, debinId: string, accountId: string, debinPaymentData?: DebinPayData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling debinsDebinIdPayAccountIdPost.');
        }

        if (debinId === null || debinId === undefined) {
            throw new Error('Required parameter debinId was null or undefined when calling debinsDebinIdPayAccountIdPost.');
        }

        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling debinsDebinIdPayAccountIdPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<DebinData>>(`${this.basePath}/debins/${encodeURIComponent(String(debinId))}/pay/${encodeURIComponent(String(accountId))}`,
            debinPaymentData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el listado de los debin con sus datos.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public debinsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<DebinData>>;
    public debinsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<DebinData>>>;
    public debinsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<DebinData>>>;
    public debinsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling debinsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<DebinData>>(`${this.basePath}/debins`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el debin con sus datos segun el id.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public debinsIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<DebinData>;
    public debinsIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DebinData>>;
    public debinsIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DebinData>>;
    public debinsIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling debinsIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling debinsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<DebinData>(`${this.basePath}/debins/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna el listado de todos los Fondos de Inversion disponibles
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fundsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<FundData>>;
    public fundsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FundData>>>;
    public fundsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FundData>>>;
    public fundsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling fundsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FundData>>(`${this.basePath}/funds`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna el fondo de inversion indicado por el Id
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public fundsIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<FundData>;
    public fundsIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FundData>>;
    public fundsIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FundData>>;
    public fundsIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling fundsIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling fundsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FundData>(`${this.basePath}/funds/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene el listado de las inversiones con sus datos.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public inversmentsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InversmentData>>;
    public inversmentsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InversmentData>>>;
    public inversmentsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InversmentData>>>;
    public inversmentsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling inversmentsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<InversmentData>>(`${this.basePath}/inversments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene los datos de la inversión determinado por el id.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public inversmentsIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<InversmentData>;
    public inversmentsIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InversmentData>>;
    public inversmentsIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InversmentData>>;
    public inversmentsIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling inversmentsIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling inversmentsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<InversmentData>(`${this.basePath}/inversments/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna toda la información asociada con el ID del Préstamo Informado.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loansIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<LoanData>;
    public loansIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoanData>>;
    public loansIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoanData>>;
    public loansIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling loansIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling loansIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LoanData>(`${this.basePath}/loans/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Realiza la simulación de un préstamo Hipotecario
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loansMortgageSimulationGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<LoanSimulationData>;
    public loansMortgageSimulationGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoanSimulationData>>;
    public loansMortgageSimulationGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoanSimulationData>>;
    public loansMortgageSimulationGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling loansMortgageSimulationGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LoanSimulationData>(`${this.basePath}/loans/mortgage_simulation`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Realiza la simulación de un préstamo Personal
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loansPersonalSimulationGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<LoanSimulationData>;
    public loansPersonalSimulationGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LoanSimulationData>>;
    public loansPersonalSimulationGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LoanSimulationData>>;
    public loansPersonalSimulationGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling loansPersonalSimulationGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LoanSimulationData>(`${this.basePath}/loans/personal_simulation`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna todos los Comercios.
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public merchantsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<MerchantData>>;
    public merchantsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MerchantData>>>;
    public merchantsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MerchantData>>>;
    public merchantsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling merchantsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<MerchantData>>(`${this.basePath}/merchants`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna el Comercio especificado por el id.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public merchantsIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<MerchantData>;
    public merchantsIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MerchantData>>;
    public merchantsIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MerchantData>>;
    public merchantsIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling merchantsIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling merchantsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<MerchantData>(`${this.basePath}/merchants/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna todas las compras asociadas con un id de Comercio especificado.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public merchantsIdPurchasesGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PurchaseData>>;
    public merchantsIdPurchasesGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PurchaseData>>>;
    public merchantsIdPurchasesGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PurchaseData>>>;
    public merchantsIdPurchasesGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling merchantsIdPurchasesGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling merchantsIdPurchasesGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PurchaseData>>(`${this.basePath}/merchants/${encodeURIComponent(String(id))}/purchases`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Modifica los datos del comercio filtrado por id
     *
     * @param apikey
     * @param id
     * @param merchantData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public merchantsIdPut(apikey: string, id: string, merchantData: MerchantCreationData, observe?: 'body', reportProgress?: boolean): Observable<MerchantData>;
    public merchantsIdPut(apikey: string, id: string, merchantData: MerchantCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MerchantData>>;
    public merchantsIdPut(apikey: string, id: string, merchantData: MerchantCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MerchantData>>;
    public merchantsIdPut(apikey: string, id: string, merchantData: MerchantCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling merchantsIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling merchantsIdPut.');
        }

        if (merchantData === null || merchantData === undefined) {
            throw new Error('Required parameter merchantData was null or undefined when calling merchantsIdPut.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<MerchantData>(`${this.basePath}/merchants/${encodeURIComponent(String(id))}`,
            merchantData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea un Comercio con los datos especificados
     *
     * @param apikey
     * @param merchantData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public merchantsPost(apikey: string, merchantData: MerchantCreationData, observe?: 'body', reportProgress?: boolean): Observable<Array<MerchantData>>;
    public merchantsPost(apikey: string, merchantData: MerchantCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<MerchantData>>>;
    public merchantsPost(apikey: string, merchantData: MerchantCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<MerchantData>>>;
    public merchantsPost(apikey: string, merchantData: MerchantCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling merchantsPost.');
        }

        if (merchantData === null || merchantData === undefined) {
            throw new Error('Required parameter merchantData was null or undefined when calling merchantsPost.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Array<MerchantData>>(`${this.basePath}/merchants`,
            merchantData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Obtiene las compras asociadas al pago.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public paymentsIdPurchasesGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<Array<PurchaseData>>;
    public paymentsIdPurchasesGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PurchaseData>>>;
    public paymentsIdPurchasesGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PurchaseData>>>;
    public paymentsIdPurchasesGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling paymentsIdPurchasesGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling paymentsIdPurchasesGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<PurchaseData>>(`${this.basePath}/payments/${encodeURIComponent(String(id))}/purchases`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna la Compra especificada en el llamado.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchasesIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<PurchaseData>;
    public purchasesIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PurchaseData>>;
    public purchasesIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PurchaseData>>;
    public purchasesIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling purchasesIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling purchasesIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<PurchaseData>(`${this.basePath}/purchases/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Crea una nueva compra
     *
     * @param apikey
     * @param purchaseCreationData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public purchasesPost(apikey: string, purchaseCreationData?: PurchaseCreationData, observe?: 'body', reportProgress?: boolean): Observable<PurchaseData>;
    public purchasesPost(apikey: string, purchaseCreationData?: PurchaseCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PurchaseData>>;
    public purchasesPost(apikey: string, purchaseCreationData?: PurchaseCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PurchaseData>>;
    public purchasesPost(apikey: string, purchaseCreationData?: PurchaseCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling purchasesPost.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PurchaseData>(`${this.basePath}/purchases`,
            purchaseCreationData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna el listado de todos las subscripciones existentes
     *
     * @param apikey
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subscriptionsGet(apikey: string, observe?: 'body', reportProgress?: boolean): Observable<Array<SubscriptionData>>;
    public subscriptionsGet(apikey: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<SubscriptionData>>>;
    public subscriptionsGet(apikey: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<SubscriptionData>>>;
    public subscriptionsGet(apikey: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling subscriptionsGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<SubscriptionData>>(`${this.basePath}/subscriptions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna la subscripcion indicada
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subscriptionsIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<SubscriptionData>;
    public subscriptionsIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubscriptionData>>;
    public subscriptionsIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubscriptionData>>;
    public subscriptionsIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling subscriptionsIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling subscriptionsIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SubscriptionData>(`${this.basePath}/subscriptions/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Actualiza los rendimientos de la subscripcion indicada y atualiza el monto actual
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public subscriptionsIdUpdateInterestPost(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<SubscriptionData>;
    public subscriptionsIdUpdateInterestPost(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SubscriptionData>>;
    public subscriptionsIdUpdateInterestPost(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SubscriptionData>>;
    public subscriptionsIdUpdateInterestPost(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling subscriptionsIdUpdateInterestPost.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling subscriptionsIdUpdateInterestPost.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<SubscriptionData>(`${this.basePath}/subscriptions/${encodeURIComponent(String(id))}/updateInterest`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retorna toda la información asociada con el ID de transferencia enviado.
     *
     * @param apikey
     * @param id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transfersIdGet(apikey: string, id: string, observe?: 'body', reportProgress?: boolean): Observable<TransferData>;
    public transfersIdGet(apikey: string, id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransferData>>;
    public transfersIdGet(apikey: string, id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransferData>>;
    public transfersIdGet(apikey: string, id: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling transfersIdGet.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling transfersIdGet.');
        }

        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TransferData>(`${this.basePath}/transfers/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Actualiza el estado de una transferencia. Aplica sólo a las transferencias en estado “Pendiente”.
     *
     * @param apikey
     * @param id
     * @param transferData
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public transfersIdPut(apikey: string, id: string, transferData?: TransferCreationData, observe?: 'body', reportProgress?: boolean): Observable<TransferData>;
    public transfersIdPut(apikey: string, id: string, transferData?: TransferCreationData, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TransferData>>;
    public transfersIdPut(apikey: string, id: string, transferData?: TransferCreationData, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TransferData>>;
    public transfersIdPut(apikey: string, id: string, transferData?: TransferCreationData, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        if (apikey === null || apikey === undefined) {
            throw new Error('Required parameter apikey was null or undefined when calling transfersIdPut.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling transfersIdPut.');
        }


        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (apikey !== undefined && apikey !== null) {
            queryParameters = queryParameters.set('apikey', <any>apikey);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<TransferData>(`${this.basePath}/transfers/${encodeURIComponent(String(id))}`,
            transferData,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
